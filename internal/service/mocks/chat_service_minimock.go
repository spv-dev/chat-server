// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/spv-dev/chat-server/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/spv-dev/chat-server/internal/model"
)

// ChatServiceMock implements mm_service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, info *model.ChatInfo) (c2 model.Chat, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, info *model.ChatInfo)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServiceMockCreateChat

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServiceMockDeleteChat

	funcGetChatInfo          func(ctx context.Context, id int64) (c2 model.Chat, err error)
	funcGetChatInfoOrigin    string
	inspectFuncGetChatInfo   func(ctx context.Context, id int64)
	afterGetChatInfoCounter  uint64
	beforeGetChatInfoCounter uint64
	GetChatInfoMock          mChatServiceMockGetChatInfo

	funcGetChatMessages          func(ctx context.Context, id int64, limit uint64, offset uint64) (mpa1 []*model.Message, err error)
	funcGetChatMessagesOrigin    string
	inspectFuncGetChatMessages   func(ctx context.Context, id int64, limit uint64, offset uint64)
	afterGetChatMessagesCounter  uint64
	beforeGetChatMessagesCounter uint64
	GetChatMessagesMock          mChatServiceMockGetChatMessages

	funcSendMessage          func(ctx context.Context, info *model.MessageInfo) (m1 model.Message, err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(ctx context.Context, info *model.MessageInfo)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for mm_service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatServiceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServiceMockCreateChatParams{}

	m.DeleteChatMock = mChatServiceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServiceMockDeleteChatParams{}

	m.GetChatInfoMock = mChatServiceMockGetChatInfo{mock: m}
	m.GetChatInfoMock.callArgs = []*ChatServiceMockGetChatInfoParams{}

	m.GetChatMessagesMock = mChatServiceMockGetChatMessages{mock: m}
	m.GetChatMessagesMock.callArgs = []*ChatServiceMockGetChatMessagesParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockCreateChat struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateChatExpectation
	expectations       []*ChatServiceMockCreateChatExpectation

	callArgs []*ChatServiceMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockCreateChatExpectation specifies expectation struct of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockCreateChatParams
	paramPtrs          *ChatServiceMockCreateChatParamPtrs
	expectationOrigins ChatServiceMockCreateChatExpectationOrigins
	results            *ChatServiceMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockCreateChatParams contains parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParams struct {
	ctx  context.Context
	info *model.ChatInfo
}

// ChatServiceMockCreateChatParamPtrs contains pointers to parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParamPtrs struct {
	ctx  *context.Context
	info **model.ChatInfo
}

// ChatServiceMockCreateChatResults contains results of the ChatService.CreateChat
type ChatServiceMockCreateChatResults struct {
	c2  model.Chat
	err error
}

// ChatServiceMockCreateChatOrigins contains origins of expectations of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatServiceMockCreateChat) Optional() *mChatServiceMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Expect(ctx context.Context, info *model.ChatInfo) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatServiceMockCreateChatParams{ctx, info}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServiceMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectInfoParam2 sets up expected param info for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) ExpectInfoParam2(info *model.ChatInfo) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServiceMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.info = &info
	mmCreateChat.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Inspect(f func(ctx context.Context, info *model.ChatInfo)) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Return(c2 model.Chat, err error) *ChatServiceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServiceMockCreateChatResults{c2, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatService.CreateChat method
func (mmCreateChat *mChatServiceMockCreateChat) Set(f func(ctx context.Context, info *model.ChatInfo) (c2 model.Chat, err error)) *ChatServiceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatService.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatService.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the ChatService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceMockCreateChat) When(ctx context.Context, info *model.ChatInfo) *ChatServiceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &ChatServiceMockCreateChatParams{ctx, info},
		expectationOrigins: ChatServiceMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateChatExpectation) Then(c2 model.Chat, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateChatResults{c2, err}
	return e.mock
}

// Times sets number of times ChatService.CreateChat should be invoked
func (mmCreateChat *mChatServiceMockCreateChat) Times(n uint64) *mChatServiceMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatServiceMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mChatServiceMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_service.ChatService
func (mmCreateChat *ChatServiceMock) CreateChat(ctx context.Context, info *model.ChatInfo) (c2 model.Chat, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, info)
	}

	mm_params := ChatServiceMockCreateChatParams{ctx, info}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockCreateChatParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServiceMock.CreateChat")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, info)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServiceMock.CreateChat. %v %v", ctx, info)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceMockCreateChat) Calls() []*ChatServiceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mChatServiceMockDeleteChat struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteChatExpectation
	expectations       []*ChatServiceMockDeleteChatExpectation

	callArgs []*ChatServiceMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockDeleteChatExpectation specifies expectation struct of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockDeleteChatParams
	paramPtrs          *ChatServiceMockDeleteChatParamPtrs
	expectationOrigins ChatServiceMockDeleteChatExpectationOrigins
	results            *ChatServiceMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockDeleteChatParams contains parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatServiceMockDeleteChatParamPtrs contains pointers to parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatServiceMockDeleteChatResults contains results of the ChatService.DeleteChat
type ChatServiceMockDeleteChatResults struct {
	err error
}

// ChatServiceMockDeleteChatOrigins contains origins of expectations of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatServiceMockDeleteChat) Optional() *mChatServiceMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Expect(ctx context.Context, id int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatServiceMockDeleteChatParams{ctx, id}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectIdParam2(id int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id
	mmDeleteChat.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Return(err error) *ChatServiceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServiceMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatService.DeleteChat method
func (mmDeleteChat *mChatServiceMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatServiceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatService.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatService.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceMockDeleteChat) When(ctx context.Context, id int64) *ChatServiceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatServiceMockDeleteChatParams{ctx, id},
		expectationOrigins: ChatServiceMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatService.DeleteChat should be invoked
func (mmDeleteChat *mChatServiceMockDeleteChat) Times(n uint64) *mChatServiceMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatServiceMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatServiceMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_service.ChatService
func (mmDeleteChat *ChatServiceMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatServiceMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServiceMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceMockDeleteChat) Calls() []*ChatServiceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatServiceMockGetChatInfo struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatInfoExpectation
	expectations       []*ChatServiceMockGetChatInfoExpectation

	callArgs []*ChatServiceMockGetChatInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockGetChatInfoExpectation specifies expectation struct of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockGetChatInfoParams
	paramPtrs          *ChatServiceMockGetChatInfoParamPtrs
	expectationOrigins ChatServiceMockGetChatInfoExpectationOrigins
	results            *ChatServiceMockGetChatInfoResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockGetChatInfoParams contains parameters of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoParams struct {
	ctx context.Context
	id  int64
}

// ChatServiceMockGetChatInfoParamPtrs contains pointers to parameters of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatServiceMockGetChatInfoResults contains results of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoResults struct {
	c2  model.Chat
	err error
}

// ChatServiceMockGetChatInfoOrigins contains origins of expectations of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Optional() *mChatServiceMockGetChatInfo {
	mmGetChatInfo.optional = true
	return mmGetChatInfo
}

// Expect sets up expected params for ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Expect(ctx context.Context, id int64) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{}
	}

	if mmGetChatInfo.defaultExpectation.paramPtrs != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by ExpectParams functions")
	}

	mmGetChatInfo.defaultExpectation.params = &ChatServiceMockGetChatInfoParams{ctx, id}
	mmGetChatInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatInfo.expectations {
		if minimock.Equal(e.params, mmGetChatInfo.defaultExpectation.params) {
			mmGetChatInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatInfo.defaultExpectation.params)
		}
	}

	return mmGetChatInfo
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) ExpectCtxParam1(ctx context.Context) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{}
	}

	if mmGetChatInfo.defaultExpectation.params != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Expect")
	}

	if mmGetChatInfo.defaultExpectation.paramPtrs == nil {
		mmGetChatInfo.defaultExpectation.paramPtrs = &ChatServiceMockGetChatInfoParamPtrs{}
	}
	mmGetChatInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatInfo
}

// ExpectIdParam2 sets up expected param id for ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) ExpectIdParam2(id int64) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{}
	}

	if mmGetChatInfo.defaultExpectation.params != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Expect")
	}

	if mmGetChatInfo.defaultExpectation.paramPtrs == nil {
		mmGetChatInfo.defaultExpectation.paramPtrs = &ChatServiceMockGetChatInfoParamPtrs{}
	}
	mmGetChatInfo.defaultExpectation.paramPtrs.id = &id
	mmGetChatInfo.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetChatInfo
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Inspect(f func(ctx context.Context, id int64)) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.inspectFuncGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatInfo")
	}

	mmGetChatInfo.mock.inspectFuncGetChatInfo = f

	return mmGetChatInfo
}

// Return sets up results that will be returned by ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Return(c2 model.Chat, err error) *ChatServiceMock {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{mock: mmGetChatInfo.mock}
	}
	mmGetChatInfo.defaultExpectation.results = &ChatServiceMockGetChatInfoResults{c2, err}
	mmGetChatInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatInfo.mock
}

// Set uses given function f to mock the ChatService.GetChatInfo method
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Set(f func(ctx context.Context, id int64) (c2 model.Chat, err error)) *ChatServiceMock {
	if mmGetChatInfo.defaultExpectation != nil {
		mmGetChatInfo.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatInfo method")
	}

	if len(mmGetChatInfo.expectations) > 0 {
		mmGetChatInfo.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatInfo method")
	}

	mmGetChatInfo.mock.funcGetChatInfo = f
	mmGetChatInfo.mock.funcGetChatInfoOrigin = minimock.CallerInfo(1)
	return mmGetChatInfo.mock
}

// When sets expectation for the ChatService.GetChatInfo which will trigger the result defined by the following
// Then helper
func (mmGetChatInfo *mChatServiceMockGetChatInfo) When(ctx context.Context, id int64) *ChatServiceMockGetChatInfoExpectation {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatInfoExpectation{
		mock:               mmGetChatInfo.mock,
		params:             &ChatServiceMockGetChatInfoParams{ctx, id},
		expectationOrigins: ChatServiceMockGetChatInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatInfo.expectations = append(mmGetChatInfo.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatInfo return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatInfoExpectation) Then(c2 model.Chat, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatInfoResults{c2, err}
	return e.mock
}

// Times sets number of times ChatService.GetChatInfo should be invoked
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Times(n uint64) *mChatServiceMockGetChatInfo {
	if n == 0 {
		mmGetChatInfo.mock.t.Fatalf("Times of ChatServiceMock.GetChatInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatInfo.expectedInvocations, n)
	mmGetChatInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatInfo
}

func (mmGetChatInfo *mChatServiceMockGetChatInfo) invocationsDone() bool {
	if len(mmGetChatInfo.expectations) == 0 && mmGetChatInfo.defaultExpectation == nil && mmGetChatInfo.mock.funcGetChatInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatInfo.mock.afterGetChatInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatInfo implements mm_service.ChatService
func (mmGetChatInfo *ChatServiceMock) GetChatInfo(ctx context.Context, id int64) (c2 model.Chat, err error) {
	mm_atomic.AddUint64(&mmGetChatInfo.beforeGetChatInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatInfo.afterGetChatInfoCounter, 1)

	mmGetChatInfo.t.Helper()

	if mmGetChatInfo.inspectFuncGetChatInfo != nil {
		mmGetChatInfo.inspectFuncGetChatInfo(ctx, id)
	}

	mm_params := ChatServiceMockGetChatInfoParams{ctx, id}

	// Record call args
	mmGetChatInfo.GetChatInfoMock.mutex.Lock()
	mmGetChatInfo.GetChatInfoMock.callArgs = append(mmGetChatInfo.GetChatInfoMock.callArgs, &mm_params)
	mmGetChatInfo.GetChatInfoMock.mutex.Unlock()

	for _, e := range mmGetChatInfo.GetChatInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetChatInfo.GetChatInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatInfo.GetChatInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatInfo.GetChatInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatInfo.GetChatInfoMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockGetChatInfoParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatInfo.t.Errorf("ChatServiceMock.GetChatInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatInfo.GetChatInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetChatInfo.t.Errorf("ChatServiceMock.GetChatInfo got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatInfo.GetChatInfoMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatInfo.t.Errorf("ChatServiceMock.GetChatInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatInfo.GetChatInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatInfo.GetChatInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatInfo.t.Fatal("No results are set for the ChatServiceMock.GetChatInfo")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetChatInfo.funcGetChatInfo != nil {
		return mmGetChatInfo.funcGetChatInfo(ctx, id)
	}
	mmGetChatInfo.t.Fatalf("Unexpected call to ChatServiceMock.GetChatInfo. %v %v", ctx, id)
	return
}

// GetChatInfoAfterCounter returns a count of finished ChatServiceMock.GetChatInfo invocations
func (mmGetChatInfo *ChatServiceMock) GetChatInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatInfo.afterGetChatInfoCounter)
}

// GetChatInfoBeforeCounter returns a count of ChatServiceMock.GetChatInfo invocations
func (mmGetChatInfo *ChatServiceMock) GetChatInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatInfo.beforeGetChatInfoCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Calls() []*ChatServiceMockGetChatInfoParams {
	mmGetChatInfo.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatInfoParams, len(mmGetChatInfo.callArgs))
	copy(argCopy, mmGetChatInfo.callArgs)

	mmGetChatInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatInfoDone returns true if the count of the GetChatInfo invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatInfoDone() bool {
	if m.GetChatInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatInfoMock.invocationsDone()
}

// MinimockGetChatInfoInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatInfoInspect() {
	for _, e := range m.GetChatInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatInfoCounter := mm_atomic.LoadUint64(&m.afterGetChatInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatInfoMock.defaultExpectation != nil && afterGetChatInfoCounter < 1 {
		if m.GetChatInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s", m.GetChatInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s with params: %#v", m.GetChatInfoMock.defaultExpectation.expectationOrigins.origin, *m.GetChatInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatInfo != nil && afterGetChatInfoCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s", m.funcGetChatInfoOrigin)
	}

	if !m.GetChatInfoMock.invocationsDone() && afterGetChatInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.GetChatInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatInfoMock.expectedInvocations), m.GetChatInfoMock.expectedInvocationsOrigin, afterGetChatInfoCounter)
	}
}

type mChatServiceMockGetChatMessages struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatMessagesExpectation
	expectations       []*ChatServiceMockGetChatMessagesExpectation

	callArgs []*ChatServiceMockGetChatMessagesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockGetChatMessagesExpectation specifies expectation struct of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockGetChatMessagesParams
	paramPtrs          *ChatServiceMockGetChatMessagesParamPtrs
	expectationOrigins ChatServiceMockGetChatMessagesExpectationOrigins
	results            *ChatServiceMockGetChatMessagesResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockGetChatMessagesParams contains parameters of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesParams struct {
	ctx    context.Context
	id     int64
	limit  uint64
	offset uint64
}

// ChatServiceMockGetChatMessagesParamPtrs contains pointers to parameters of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesParamPtrs struct {
	ctx    *context.Context
	id     *int64
	limit  *uint64
	offset *uint64
}

// ChatServiceMockGetChatMessagesResults contains results of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesResults struct {
	mpa1 []*model.Message
	err  error
}

// ChatServiceMockGetChatMessagesOrigins contains origins of expectations of the ChatService.GetChatMessages
type ChatServiceMockGetChatMessagesExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Optional() *mChatServiceMockGetChatMessages {
	mmGetChatMessages.optional = true
	return mmGetChatMessages
}

// Expect sets up expected params for ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Expect(ctx context.Context, id int64, limit uint64, offset uint64) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{}
	}

	if mmGetChatMessages.defaultExpectation.paramPtrs != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by ExpectParams functions")
	}

	mmGetChatMessages.defaultExpectation.params = &ChatServiceMockGetChatMessagesParams{ctx, id, limit, offset}
	mmGetChatMessages.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatMessages.expectations {
		if minimock.Equal(e.params, mmGetChatMessages.defaultExpectation.params) {
			mmGetChatMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatMessages.defaultExpectation.params)
		}
	}

	return mmGetChatMessages
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) ExpectCtxParam1(ctx context.Context) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{}
	}

	if mmGetChatMessages.defaultExpectation.params != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Expect")
	}

	if mmGetChatMessages.defaultExpectation.paramPtrs == nil {
		mmGetChatMessages.defaultExpectation.paramPtrs = &ChatServiceMockGetChatMessagesParamPtrs{}
	}
	mmGetChatMessages.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatMessages.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatMessages
}

// ExpectIdParam2 sets up expected param id for ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) ExpectIdParam2(id int64) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{}
	}

	if mmGetChatMessages.defaultExpectation.params != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Expect")
	}

	if mmGetChatMessages.defaultExpectation.paramPtrs == nil {
		mmGetChatMessages.defaultExpectation.paramPtrs = &ChatServiceMockGetChatMessagesParamPtrs{}
	}
	mmGetChatMessages.defaultExpectation.paramPtrs.id = &id
	mmGetChatMessages.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetChatMessages
}

// ExpectLimitParam3 sets up expected param limit for ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) ExpectLimitParam3(limit uint64) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{}
	}

	if mmGetChatMessages.defaultExpectation.params != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Expect")
	}

	if mmGetChatMessages.defaultExpectation.paramPtrs == nil {
		mmGetChatMessages.defaultExpectation.paramPtrs = &ChatServiceMockGetChatMessagesParamPtrs{}
	}
	mmGetChatMessages.defaultExpectation.paramPtrs.limit = &limit
	mmGetChatMessages.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetChatMessages
}

// ExpectOffsetParam4 sets up expected param offset for ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) ExpectOffsetParam4(offset uint64) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{}
	}

	if mmGetChatMessages.defaultExpectation.params != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Expect")
	}

	if mmGetChatMessages.defaultExpectation.paramPtrs == nil {
		mmGetChatMessages.defaultExpectation.paramPtrs = &ChatServiceMockGetChatMessagesParamPtrs{}
	}
	mmGetChatMessages.defaultExpectation.paramPtrs.offset = &offset
	mmGetChatMessages.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetChatMessages
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Inspect(f func(ctx context.Context, id int64, limit uint64, offset uint64)) *mChatServiceMockGetChatMessages {
	if mmGetChatMessages.mock.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatMessages")
	}

	mmGetChatMessages.mock.inspectFuncGetChatMessages = f

	return mmGetChatMessages
}

// Return sets up results that will be returned by ChatService.GetChatMessages
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Return(mpa1 []*model.Message, err error) *ChatServiceMock {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	if mmGetChatMessages.defaultExpectation == nil {
		mmGetChatMessages.defaultExpectation = &ChatServiceMockGetChatMessagesExpectation{mock: mmGetChatMessages.mock}
	}
	mmGetChatMessages.defaultExpectation.results = &ChatServiceMockGetChatMessagesResults{mpa1, err}
	mmGetChatMessages.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatMessages.mock
}

// Set uses given function f to mock the ChatService.GetChatMessages method
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Set(f func(ctx context.Context, id int64, limit uint64, offset uint64) (mpa1 []*model.Message, err error)) *ChatServiceMock {
	if mmGetChatMessages.defaultExpectation != nil {
		mmGetChatMessages.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatMessages method")
	}

	if len(mmGetChatMessages.expectations) > 0 {
		mmGetChatMessages.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatMessages method")
	}

	mmGetChatMessages.mock.funcGetChatMessages = f
	mmGetChatMessages.mock.funcGetChatMessagesOrigin = minimock.CallerInfo(1)
	return mmGetChatMessages.mock
}

// When sets expectation for the ChatService.GetChatMessages which will trigger the result defined by the following
// Then helper
func (mmGetChatMessages *mChatServiceMockGetChatMessages) When(ctx context.Context, id int64, limit uint64, offset uint64) *ChatServiceMockGetChatMessagesExpectation {
	if mmGetChatMessages.mock.funcGetChatMessages != nil {
		mmGetChatMessages.mock.t.Fatalf("ChatServiceMock.GetChatMessages mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatMessagesExpectation{
		mock:               mmGetChatMessages.mock,
		params:             &ChatServiceMockGetChatMessagesParams{ctx, id, limit, offset},
		expectationOrigins: ChatServiceMockGetChatMessagesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatMessages.expectations = append(mmGetChatMessages.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatMessages return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatMessagesExpectation) Then(mpa1 []*model.Message, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatMessagesResults{mpa1, err}
	return e.mock
}

// Times sets number of times ChatService.GetChatMessages should be invoked
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Times(n uint64) *mChatServiceMockGetChatMessages {
	if n == 0 {
		mmGetChatMessages.mock.t.Fatalf("Times of ChatServiceMock.GetChatMessages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatMessages.expectedInvocations, n)
	mmGetChatMessages.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatMessages
}

func (mmGetChatMessages *mChatServiceMockGetChatMessages) invocationsDone() bool {
	if len(mmGetChatMessages.expectations) == 0 && mmGetChatMessages.defaultExpectation == nil && mmGetChatMessages.mock.funcGetChatMessages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatMessages.mock.afterGetChatMessagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatMessages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatMessages implements mm_service.ChatService
func (mmGetChatMessages *ChatServiceMock) GetChatMessages(ctx context.Context, id int64, limit uint64, offset uint64) (mpa1 []*model.Message, err error) {
	mm_atomic.AddUint64(&mmGetChatMessages.beforeGetChatMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatMessages.afterGetChatMessagesCounter, 1)

	mmGetChatMessages.t.Helper()

	if mmGetChatMessages.inspectFuncGetChatMessages != nil {
		mmGetChatMessages.inspectFuncGetChatMessages(ctx, id, limit, offset)
	}

	mm_params := ChatServiceMockGetChatMessagesParams{ctx, id, limit, offset}

	// Record call args
	mmGetChatMessages.GetChatMessagesMock.mutex.Lock()
	mmGetChatMessages.GetChatMessagesMock.callArgs = append(mmGetChatMessages.GetChatMessagesMock.callArgs, &mm_params)
	mmGetChatMessages.GetChatMessagesMock.mutex.Unlock()

	for _, e := range mmGetChatMessages.GetChatMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.err
		}
	}

	if mmGetChatMessages.GetChatMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatMessages.GetChatMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockGetChatMessagesParams{ctx, id, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatMessages.t.Errorf("ChatServiceMock.GetChatMessages got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatMessages.GetChatMessagesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetChatMessages.t.Errorf("ChatServiceMock.GetChatMessages got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatMessages.GetChatMessagesMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetChatMessages.t.Errorf("ChatServiceMock.GetChatMessages got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatMessages.GetChatMessagesMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetChatMessages.t.Errorf("ChatServiceMock.GetChatMessages got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatMessages.GetChatMessagesMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatMessages.t.Errorf("ChatServiceMock.GetChatMessages got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatMessages.GetChatMessagesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatMessages.GetChatMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatMessages.t.Fatal("No results are set for the ChatServiceMock.GetChatMessages")
		}
		return (*mm_results).mpa1, (*mm_results).err
	}
	if mmGetChatMessages.funcGetChatMessages != nil {
		return mmGetChatMessages.funcGetChatMessages(ctx, id, limit, offset)
	}
	mmGetChatMessages.t.Fatalf("Unexpected call to ChatServiceMock.GetChatMessages. %v %v %v %v", ctx, id, limit, offset)
	return
}

// GetChatMessagesAfterCounter returns a count of finished ChatServiceMock.GetChatMessages invocations
func (mmGetChatMessages *ChatServiceMock) GetChatMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.afterGetChatMessagesCounter)
}

// GetChatMessagesBeforeCounter returns a count of ChatServiceMock.GetChatMessages invocations
func (mmGetChatMessages *ChatServiceMock) GetChatMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatMessages.beforeGetChatMessagesCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatMessages *mChatServiceMockGetChatMessages) Calls() []*ChatServiceMockGetChatMessagesParams {
	mmGetChatMessages.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatMessagesParams, len(mmGetChatMessages.callArgs))
	copy(argCopy, mmGetChatMessages.callArgs)

	mmGetChatMessages.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatMessagesDone returns true if the count of the GetChatMessages invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatMessagesDone() bool {
	if m.GetChatMessagesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatMessagesMock.invocationsDone()
}

// MinimockGetChatMessagesInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatMessagesInspect() {
	for _, e := range m.GetChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatMessagesCounter := mm_atomic.LoadUint64(&m.afterGetChatMessagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMessagesMock.defaultExpectation != nil && afterGetChatMessagesCounter < 1 {
		if m.GetChatMessagesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages at\n%s", m.GetChatMessagesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages at\n%s with params: %#v", m.GetChatMessagesMock.defaultExpectation.expectationOrigins.origin, *m.GetChatMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatMessages != nil && afterGetChatMessagesCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.GetChatMessages at\n%s", m.funcGetChatMessagesOrigin)
	}

	if !m.GetChatMessagesMock.invocationsDone() && afterGetChatMessagesCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.GetChatMessages at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatMessagesMock.expectedInvocations), m.GetChatMessagesMock.expectedInvocationsOrigin, afterGetChatMessagesCounter)
	}
}

type mChatServiceMockSendMessage struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockSendMessageParams
	paramPtrs          *ChatServiceMockSendMessageParamPtrs
	expectationOrigins ChatServiceMockSendMessageExpectationOrigins
	results            *ChatServiceMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx  context.Context
	info *model.MessageInfo
}

// ChatServiceMockSendMessageParamPtrs contains pointers to parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParamPtrs struct {
	ctx  *context.Context
	info **model.MessageInfo
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	m1  model.Message
	err error
}

// ChatServiceMockSendMessageOrigins contains origins of expectations of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatServiceMockSendMessage) Optional() *mChatServiceMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, info *model.MessageInfo) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, info}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectInfoParam2 sets up expected param info for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectInfoParam2(info *model.MessageInfo) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.info = &info
	mmSendMessage.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, info *model.MessageInfo)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(m1 model.Message, err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{m1, err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, info *model.MessageInfo) (m1 model.Message, err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, info *model.MessageInfo) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &ChatServiceMockSendMessageParams{ctx, info},
		expectationOrigins: ChatServiceMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(m1 model.Message, err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{m1, err}
	return e.mock
}

// Times sets number of times ChatService.SendMessage should be invoked
func (mmSendMessage *mChatServiceMockSendMessage) Times(n uint64) *mChatServiceMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatServiceMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mChatServiceMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, info *model.MessageInfo) (m1 model.Message, err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, info)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, info}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockSendMessageParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, info)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v", ctx, info)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetChatInfoInspect()

			m.MinimockGetChatMessagesInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetChatInfoDone() &&
		m.MinimockGetChatMessagesDone() &&
		m.MinimockSendMessageDone()
}
